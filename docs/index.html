<!--daedalus build --onefile ./examples/minesweeper.js ./docs-->
<!DOCTYPE html>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no,user-scalable=no">
<html lang="en">
<head>
<link rel="icon" type="image/x-icon" href="/favicon.ico" />
<title>Daedalus</title>
<style type="text/css">
.dcs-14b6e0af-0 {
  cursor: pointer;
  color: blue;
}
.dcs-14b6e0af-1 {
  background-color: #edf2f7;
  border: 2px dashed #cbd5e0;
  width: 100%;
  height: 100%;
}
.dcs-dbe5cb86-0 {
  text-align: center;
}
.dcs-dbe5cb86-1 {
  margin: 0;
  padding: 0;
  display: block;
}
.dcs-dbe5cb86-2 {
  margin: 0 auto;
  display: inline-block;
}
.dcs-dbe5cb86-3 {
  border-style: outset;
  background: #AAAAAA;
  width: 1.7em;
  height: 1.7em;
  margin: 0;
  padding: 0;
  display: inline-block;
  text-align: center;
  vertical-align: middle;
  font-weight: 900;
}
.dcs-dbe5cb86-4 {
  border-style: inset;
  background: #CCCCCC;
  width: 1.7em;
  height: 1.7em;
  margin: 0;
  padding: 0;
  display: inline-block;
  text-align: center;
  vertical-align: middle;
  font-weight: 900;
}
.dcs-dbe5cb86-5 {
  border-style: outset;
  background: #003388;
  width: 1.7em;
  height: 1.7em;
  margin: 0;
  padding: 0;
  display: inline-block;
  text-align: center;
  vertical-align: middle;
  font-weight: 900;
}
.dcs-dbe5cb86-6 {
  border-style: inset;
  background: #880000;
  width: 1.7em;
  height: 1.7em;
  margin: 0;
  padding: 0;
  display: inline-block;
  text-align: center;
  vertical-align: middle;
  font-weight: 900;
}
.dcs-dbe5cb86-7 {
  padding-bottom: 1em;
}
.dcs-dbe5cb86-8 {
  text-align: center;
}
.dcs-dbe5cb86-9 {
  display: block;
}
.dcs-dbe5cb86-10 {
  border-radius: .5em;
  border-color: #085923;
  border-style: solid;
  border-width: 1px;
  background-image: linear-gradient(#14cc51, #0a6628);
  text-align: center;
  padding: .3em;
}
.dcs-dbe5cb86-11 {
  border-radius: 0 0 .5em .5em;
  border-color: #646464;
  border-style: solid;
  border-width: 1px;
  background-image: linear-gradient(#D5D5D5, #7A7A7A);
  text-align: left;
  padding-top: .25em;
  padding-bottom: .25em;
  padding-left: 1em;
  padding-right: 1em;
}
.dcs-dbe5cb86-12 {
  padding-top: .25em;
  padding-bottom: .25em;
  padding-left: 1em;
  padding-right: 1em;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.dcs-dbe5cb86-13 {
  width: 3em;
}
.dcs-dbe5cb86-10:hover {
  background-image: linear-gradient(#0c7f33, #063f19);
}
.dcs-dbe5cb86-10:active {
  background-image: linear-gradient(#063f19, #0c7f33);
}
</style>
<script type="text/javascript">
AndroidEvents = {}
function registerAndroidEvent(name, callback) {
    AndroidEvents[name] = callback;
}
function invokeAndroidEvent(name, payload) {
    //console.log(`invoke event '${name}': ${payload}`)
    if (!!AndroidEvents[name]) {
        AndroidEvents[name](JSON.parse(payload));
    } else {
        console.error("unregistered event: " + name);
    }
}
</script>
<script type="text/javascript">
daedalus=(function(){
    "use strict";
    const env={};
    const build_platform="web";
    const[StyleSheet,getStyleSheet,parseParameters,util]=(function(){
        function array_move(arr,p1,p2){
          let s1=p1;
          let s2=p2;
          if(p1<0){
            p1=0;
          };
          if(p2<0){
            p2=0;
          };
          if(p1>arr.length){
            p1=arr.length;
          };
          if(p2>arr.length){
            p2=arr.length;
          };
          if(p1==p2){
            return;
          };
          arr.splice(p2,0,arr.splice(p1,1)[0]);
          return;
        };
        function randomFloat(min,max){
          return Math.random()*(max-min)+min;
        };
        function randomInt(min,max){
          min=Math.ceil(min);
          max=Math.floor(max);
          return Math.floor(Math.random()*(max-min+1))+min;
        };
        function object2style_helper(prefix,obj){
          const items=Object.keys(obj).map(key=>{
              const type=typeof(obj[key]);
              if(type==="object"){
                return object2style_helper(prefix+key+"-",obj[key]);
              }else{
                return[prefix+key+": "+obj[key]];
              };
            });
          return[].concat.apply([],items);
        };
        function object2style(obj){
          const arr=object2style_helper("",obj);
          return[].concat.apply([],arr).join(';');
        };
        function serializeParameters(obj){
          if(Object.keys(obj).length==0){
            return"";
          };
          const strings=Object.keys(obj).reduce(function(a,k){
              if(obj[k]===null||obj[k]===undefined){

              }else if(Array.isArray(obj[k])){
                for(let i=0;i<obj[k].length;i++){
                  a.push(encodeURIComponent(k)+'='+encodeURIComponent(obj[k][i]));
                  
                };
              }else{
                a.push(encodeURIComponent(k)+'='+encodeURIComponent(obj[k]));
              };
              return a;
            },[]);
          return'?'+strings.join('&');
        };
        function parseParameters(text=undefined){
          let match,search=/([^&=]+)=?([^&]*)/g,decode=s=>decodeURIComponent(s.replace(
                          /\+/g," ")),query=(text===undefined)?window.location.search.substring(
                      1):text;
          let urlParams={};
          while(match=search.exec(query)){
            let value=decode(match[2]);
            let key=decode(match[1]);
            if(urlParams[key]===undefined){
              urlParams[key]=[value];
            }else{
              urlParams[key].push(value);
            };
          };
          return urlParams;
        };
        function isFunction(x){
          return(x instanceof Function);
        };
        function joinpath(...parts){
          let str="";
          for(let i=0;i<parts.length;i++){
            if(!str.endsWith("/")&&!parts[i].startsWith("/")){
              str+="/";
            };
            str+=parts[i];
          };
          return str;
        };
        function splitpath(path){
          const parts=path.split('/');
          if(parts.length>0&&parts[parts.length-1].length===0){
            parts.pop();
          };
          return parts;
        };
        function dirname(path){
          const parts=path.split('/');
          while(parts.length>0&&parts[parts.length-1].length===0){
            parts.pop();
          };
          return joinpath(...parts.slice(0,-1));
        };
        function splitext(name){
          const index=name.lastIndexOf('.');
          if(index<=0||name[index-1]=='/'){
            return[name,''];
          }else{
            return[name.slice(0,index),name.slice(index)];
          };
        };
        let css_sheet=null;
        let selector_names={};
        function generateStyleSheetName(){
          const chars='abcdefghijklmnopqrstuvwxyz';
          let name;
          do{
            name="css-";
            for(let i=0;i<6;i++){
              let c=chars[randomInt(0,chars.length-1)];
              name+=c;
            };
          }while(selector_names[name]!==undefined);
          return name;
        };
        function shuffle(array){
          let currentIndex=array.length,temporaryValue,randomIndex;
          while(0!==currentIndex){
            randomIndex=Math.floor(Math.random()*currentIndex);
            currentIndex-=1;
            temporaryValue=array[currentIndex];
            array[currentIndex]=array[randomIndex];
            array[randomIndex]=temporaryValue;
          };
          return array;
        };
        function StyleSheet(...args){
          let name;
          let style;
          let selector;
          if(args.length===1){
            name=generateStyleSheetName();
            selector="."+name;
            style=args[0];
          }else if(args.length===2){
            selector=args[0];
            style=args[1];
            name=selector;
          };
          if(css_sheet===null){
            css_sheet=document.createElement('style');
            css_sheet.type='text/css';
            document.head.appendChild(css_sheet);
          };
          const text=object2style(style);
          selector_names[name]=style;
          if(!(css_sheet.sheet||{}).insertRule){
            (css_sheet.styleSheet||css_sheet.sheet).addRule(selector,text);
          }else{
            css_sheet.sheet.insertRule(selector+"{"+text+"}",css_sheet.sheet.rules.length);
            
          };
          return name;
        };
        function getStyleSheet(name){
          return selector_names[name];
        };
        function perf_timer(){
          return performance.now();
        };
        const util={array_move,randomInt,randomFloat,object2style,serializeParameters,
                  parseParameters,isFunction,joinpath,splitpath,dirname,splitext,shuffle,
                  perf_timer};
        return[StyleSheet,getStyleSheet,parseParameters,util];
      })();
    const[ButtonElement,DomElement,DraggableList,HeaderElement,LinkElement,ListElement,
          ListItemElement,NumberInputElement,Signal,TextElement,TextInputElement]=(function(
            ){
        let sigal_counter=0;
        function Signal(element,name){
          const event_name="onSignal_"+(sigal_counter++)+"_"+name;
          const signal={};
          signal._event_name=event_name;
          signal._slots=[];
          signal.emit=(obj=null)=>{
            signal._slots.map(item=>{
                requestIdleCallback(()=>{
                    item.callback(obj);
                  });
              });
          };
          console.log("signal create:"+event_name);
          if(!!element){
            element.signals.push(signal);
          };
          return signal;
        };
        let element_uid=0;
        function generateElementId(){
          const chars='abcdefghijklmnopqrstuvwxyz';
          let name;
          name="-";
          for(let i=0;i<6;i++){
            let c=chars[util.randomInt(0,chars.length-1)];
            name+=c;
          };
          return name+"-"+(element_uid++);
        };
        class DomElement{
          constructor(type,props,children){
            if(type===undefined){
              throw`DomElement type is undefined. super called with ${arguments.length} arguments`;
              
            };
            this.type=type;
            if(props===undefined){
              this.props={};
            }else{
              this.props=props;
            };
            if(this.props.id===undefined){
              this.props.id=this.constructor.name+generateElementId();
            };
            if(children===undefined){
              this.children=[];
            }else{
              this.children=children;
            };
            this.signals=[];
            this.slots=[];
            this.dirty=true;
            this.state={};
            this.attrs={};
            this._fiber=null;
            Object.getOwnPropertyNames(this.__proto__).filter(key=>key.startsWith(
                              "on")).forEach(key=>{
                this.props[key]=this[key].bind(this);
              });
          };
          _update(element){

          };
          update(){
            this._update(this);
          };
          updateState(state,doUpdate){
            const newState={...this.state,...state};
            if(doUpdate!==false){
              if((doUpdate===true)||(this.elementUpdateState===undefined)||(this.elementUpdateState(
                                      this.state,newState)!==false)){
                this.update();
              };
            };
            this.state=newState;
          };
          updateProps(props,doUpdate){
            const newProps={...this.props,...props};
            if(doUpdate!==false){
              if((doUpdate===true)||(this.elementUpdateProps===undefined)||(this.elementUpdateProps(
                                      this.props,newProps)!==false)){
                this.update();
              };
            };
            this.props=newProps;
          };
          appendChild(childElement){
            if(!childElement||!childElement.type){
              throw"invalid child";
            };
            if(typeof this.children==="string"){
              this.children=[this.children];
            }else if(typeof this.children==="undefined"){
              this.children=[];
            };
            this.children.push(childElement);
            this.update();
            return childElement;
          };
          insertChild(index,childElement){
            if(!childElement||!childElement.type){
              throw"invalid child";
            };
            if(index<0){
              index+=this.children.length+1;
            };
            if(index<0||index>this.children.length){
              console.error("invalid index: "+index);
              return;
            };
            if(typeof this.children==="string"){
              this.children=[this.children];
            }else if(typeof this.children==="undefined"){
              this.children=[];
            };
            this.children.splice(index,0,childElement);
            this.update();
            return childElement;
          };
          removeChild(childElement){
            if(!childElement||!childElement.type){
              throw"invalid child";
            };
            const index=this.children.indexOf(childElement);
            if(index>=0){
              this.children.splice(index,1);
              this.update();
            }else{
              console.error("child not in list");
            };
          };
          removeChildren(){
            this.children.splice(0,this.children.length);
            this.update();
          };
          replaceChild(childElement,newChildElement){
            const index=this.children.indexOf(childElement);
            if(index>=0){
              this.children[index]=newChildElement;
              this.update();
            };
          };
          addClassName(cls){
            let props;
            if(!this.props.className){
              props={className:cls};
            }else if(Array.isArray(this.props.className)){
              props={className:[cls,...this.props.className]};
            }else{
              props={className:[cls,this.props.className]};
            };
            this.updateProps(props);
          };
          removeClassName(cls){
            let props;
            if(Array.isArray(this.props.className)){
              props={className:this.props.className.filter(x=>x!==cls)};
              if(props.className.length===this.props.className.length){
                return;
              };
              this.updateProps(props);
            }else if(this.props.className===cls){
              props={className:null};
              this.updateProps(props);
            };
          };
          hasClassName(cls){
            let props;
            if(Array.isArray(this.props.className)){
              return this.props.className.filter(x=>x===cls).length===1;
            };
            return this.props.className===cls;
          };
          connect(signal,callback){
            console.log("signal connect:"+signal._event_name,callback);
            const ref={element:this,signal:signal,callback:callback};
            signal._slots.push(ref);
            this.slots.push(ref);
          };
          disconnect(signal){
            console.log("signal disconnect:"+signal._event_name);
          };
          getDomNode(){
            return this._fiber&&this._fiber.dom;
          };
          isMounted(){
            return this._fiber!==null;
          };
        };
        class TextElement extends DomElement {
          constructor(text,props={}){
            super("TEXT_ELEMENT",{'nodeValue':text,...props},[]);
          };
          setText(text){
            this.props={'nodeValue':text};
            this.update();
          };
          getText(){
            return this.props.nodeValue;
          };
        };
        class LinkElement extends DomElement {
          constructor(text,url){
            super("div",{className:LinkElement.style.link,title:url},[new TextElement(
                                  text)]);
            this.state={url};
          };
          onClick(){
            if(this.state.url.startsWith('http')){
              window.open(this.state.url,'_blank');
            }else{
              history.pushState({},"",this.state.url);
            };
          };
        };
        LinkElement.style={link:'dcs-14b6e0af-0'};
        class ListElement extends DomElement {
          constructor(){
            super("ul",{},[]);
          };
        };
        class ListItemElement extends DomElement {
          constructor(item){
            super("li",{},[item]);
          };
        };
        class HeaderElement extends DomElement {
          constructor(text=""){
            super("h1",{},[]);
            this.node=this.appendChild(new TextElement(text));
          };
          setText(text){
            this.node.setText(text);
          };
        };
        class ButtonElement extends DomElement {
          constructor(text,onClick){
            super("button",{'onClick':onClick},[new TextElement(text)]);
          };
          setText(text){
            this.children[0].setText(text);
          };
          getText(){
            return this.children[0].props.nodeValue;
          };
        };
        class TextInputElement extends DomElement {
          constructor(text,_,submit_callback){
            super("input",{value:text},[]);
            this.textChanged=Signal(this,'textChanged');
            this.attrs={submit_callback};
          };
          setText(text){
            this.updateProps({value:text});
            this.textChanged.emit(this.props);
          };
          onChange(event){
            this.updateProps({value:event.target.value},false);
            this.textChanged.emit(this.props);
          };
          onPaste(event){
            this.updateProps({value:event.target.value},false);
            this.textChanged.emit(this.props);
          };
          onKeyUp(event){
            this.updateProps({value:event.target.value},false);
            this.textChanged.emit(this.props);
            if(event.key=="Enter"){
              if(this.attrs.submit_callback){
                this.attrs.submit_callback(this.props.value);
              };
            };
          };
        };
        class NumberInputElement extends DomElement {
          constructor(value){
            super("input",{value:value,type:"number"},[]);
            this.valueChanged=Signal(this,'valueChanged');
          };
          onChange(event){
            this.updateProps({value:parseInt(event.target.value,10)},false);
            this.valueChanged.emit(this.props);
          };
          onPaste(event){
            this.updateProps({value:parseInt(event.target.value,10)},false);
            this.valueChanged.emit(this.props);
          };
          onKeyUp(event){
            this.updateProps({value:parseInt(event.target.value,10)},false);
            this.valueChanged.emit(this.props);
          };
          onInput(event){
            this.updateProps({value:parseInt(event.target.value,10)},false);
            this.valueChanged.emit(this.props);
          };
        };
        function swap(nodeA,nodeB){
          if(!nodeA||!nodeB){
            return;
          };
          const parentA=nodeA.parentNode;
          const siblingA=nodeA.nextSibling===nodeB?nodeA:nodeA.nextSibling;
          nodeB.parentNode.insertBefore(nodeA,nodeB);
          parentA.insertBefore(nodeB,siblingA);
        };
        function isAbove(nodeA,nodeB){
          if(!nodeA||!nodeB){
            return false;
          };
          const rectA=nodeA.getBoundingClientRect();
          const rectB=nodeB.getBoundingClientRect();
          return(rectA.top+rectA.height/2<rectB.top+rectB.height/2);
        };
        function childIndex(node){
          let count=0;
          while((node=node.previousSibling)!=null){
            count++;
          };
          return count;
        };
        const placeholder='dcs-14b6e0af-1';
        class DraggableListItem extends DomElement {
          constructor(){
            super("div",{},[]);
          };
          onTouchStart(event){
            this.attrs.parent.handleChildDragBegin(this,event);
          };
          onTouchMove(event){
            this.attrs.parent.handleChildDragMove(this,event);
          };
          onTouchEnd(event){
            this.attrs.parent.handleChildDragEnd(this,{target:this.getDomNode()});
            
          };
          onTouchCancel(event){
            this.attrs.parent.handleChildDragEnd(this,{target:this.getDomNode()});
            
          };
          onMouseDown(event){
            this.attrs.parent.handleChildDragBegin(this,event);
          };
          onMouseMove(event){
            this.attrs.parent.handleChildDragMove(this,event);
          };
          onMouseLeave(event){
            this.attrs.parent.handleChildDragEnd(this,event);
          };
          onMouseUp(event){
            this.attrs.parent.handleChildDragEnd(this,event);
          };
        };
        class DraggableList extends DomElement {
          constructor(){
            super("div",{},[]);
            this.attrs={x:null,y:null,placeholder:null,placeholderClassName:placeholder,
                          draggingEle:null,isDraggingStarted:false,indexStart:-1,lockX:true};
            
          };
          setPlaceholderClassName(className){
            this.attrs.placeholderClassName=className;
          };
          handleChildDragBegin(child,event){
            event.preventDefault();
            if(!!this.attrs.draggingEle){
              this.handleChildDragCancel();
              return;
            };
            let evt=(((event)||{}).touches||((((event)||{}).originalEvent)||{}).touches);
            
            if(evt){
              event=evt[0];
            };
            this.attrs.draggingEle=child.getDomNode();
            this.attrs.indexStart=childIndex(this.attrs.draggingEle);
            const rect=this.attrs.draggingEle.getBoundingClientRect();
            this.attrs.x=event.clientX-rect.left;
            this.attrs.y=event.pageY-rect.top;
          };
          handleChildDragMove(child,event){
            if(!this.attrs.draggingEle||this.attrs.draggingEle!==child.getDomNode(
                            )){
              return;
            };
            event.preventDefault();
            let evt=(((event)||{}).touches||((((event)||{}).originalEvent)||{}).touches);
            
            if(evt){
              event=evt[0];
            };
            const draggingRect=this.attrs.draggingEle.getBoundingClientRect();
            if(!this.attrs.isDraggingStarted){
              this.attrs.isDraggingStarted=true;
              this.attrs.placeholder=document.createElement('div');
              this.attrs.placeholder.classList.add(this.attrs.placeholderClassName);
              
              this.attrs.draggingEle.parentNode.insertBefore(this.attrs.placeholder,
                              this.attrs.draggingEle.nextSibling);
              this.attrs.placeholder.style.height=`${draggingRect.height}px`;
            };
            this.attrs.draggingEle.style.position='absolute';
            let ypos=event.pageY-this.attrs.y+window.scrollY;
            this.attrs.draggingEle.style.top=`${ypos}px`;
            if(!this.attrs.lockX){
              this.attrs.draggingEle.style.left=`${event.pageX-this.attrs.x}px`;
            };
            const prevEle=this.attrs.draggingEle.previousElementSibling;
            const nextEle=this.attrs.placeholder.nextElementSibling;
            if(prevEle&&isAbove(this.attrs.draggingEle,prevEle)){
              swap(this.attrs.placeholder,this.attrs.draggingEle);
              swap(this.attrs.placeholder,prevEle);
              return;
            };
            if(nextEle&&isAbove(nextEle,this.attrs.draggingEle)){
              swap(nextEle,this.attrs.placeholder);
              swap(nextEle,this.attrs.draggingEle);
            };
          };
          handleChildDragEnd(child,event){
            if(!this.attrs.draggingEle||this.attrs.draggingEle!==child.getDomNode(
                            )){
              return;
            };
            this.handleChildDragCancel();
          };
          handleChildDragCancel(){
            this.attrs.placeholder&&this.attrs.placeholder.parentNode.removeChild(
                          this.attrs.placeholder);
            this.attrs.draggingEle.style.removeProperty('top');
            this.attrs.draggingEle.style.removeProperty('left');
            this.attrs.draggingEle.style.removeProperty('position');
            const indexEnd=childIndex(this.attrs.draggingEle);
            this.updateModel(this.attrs.indexStart,indexEnd);
            this.attrs.x=null;
            this.attrs.y=null;
            this.attrs.draggingEle=null;
            this.attrs.isDraggingStarted=false;
          };
          updateModel(indexStart,indexEnd){
            this.children.splice(indexEnd,0,this.children.splice(indexStart,1)[0]);
            
          };
        };
        return[ButtonElement,DomElement,DraggableList,HeaderElement,LinkElement,ListElement,
                  ListItemElement,NumberInputElement,Signal,TextElement,TextInputElement];
        
      })();
    const[]=(function(){
        history.locationChanged=Signal(null,"locationChanged");
        history._pushState=history.pushState;
        history.pushState=(state,title,path)=>{
          history._pushState(state,title,path);
          history.locationChanged.emit({path:location.pathname});
        };
        window.addEventListener('popstate',(event)=>{
            history.locationChanged.emit({path:location.pathname});
          });
        return[];
      })();
    const[AuthenticatedRouter,Router,locationMatch,patternCompile,patternToRegexp]=(
          function(){
        function patternCompile(pattern){
          const arr=pattern.split('/');
          let tokens=[];
          for(let i=1;i<arr.length;i++){
            let part=arr[i];
            if(part.startsWith(':')){
              if(part.endsWith('?')){
                tokens.push({param:true,name:part.substr(1,part.length-2)});
              }else if(part.endsWith('+')){
                tokens.push({param:true,name:part.substr(1,part.length-2)});
              }else if(part.endsWith('*')){
                tokens.push({param:true,name:part.substr(1,part.length-2)});
              }else{
                tokens.push({param:true,name:part.substr(1)});
              };
            }else{
              tokens.push({param:false,value:part});
            };
          };
          return(items,query_items)=>{
            let location='';
            for(let i=0;i<tokens.length;i++){
              location+='/';
              if(tokens[i].param){
                location+=items[tokens[i].name];
              }else{
                location+=tokens[i].value;
              };
            };
            if(!!query_items){
              location+=util.serializeParameters(query_items);
            };
            return location;
          };
        };
        function patternToRegexp(pattern,exact=true){
          const arr=pattern.split('/');
          let re="^";
          let tokens=[];
          for(let i=exact?1:0;i<arr.length;i++){
            let part=arr[i];
            if(i==0&&exact===false){

            }else{
              re+="\\/";
            };
            if(part.startsWith(':')){
              if(part.endsWith('?')){
                tokens.push(part.substr(1,part.length-2));
                re+="([^\\/]*)";
              }else if(part.endsWith('+')){
                tokens.push(part.substr(1,part.length-2));
                re+="?(.+)";
              }else if(part.endsWith('*')){
                tokens.push(part.substr(1,part.length-2));
                re+="?(.*)";
              }else{
                tokens.push(part.substr(1));
                re+="([^\\/]+)";
              };
            }else{
              re+=part;
            };
          };
          if(re!=="^\\/"){
            re+="\\/?";
          };
          re+="$";
          return{re:new RegExp(re,"i"),text:re,tokens};
        };
        function locationMatch(obj,location){
          obj.re.lastIndex=0;
          let arr=location.match(obj.re);
          if(arr==null){
            return null;
          };
          let result={};
          for(let i=1;i<arr.length;i++){
            result[obj.tokens[i-1]]=arr[i];
          };
          return result;
        };
        function patternMatch(pattern,location){
          return locationMatch(patternToRegexp(pattern),location);
        };
        class Router{
          constructor(container,default_callback){
            if(!container){
              throw'invalid container';
            };
            this.container=container;
            this.default_callback=default_callback;
            this.routes=[];
            this.current_index=-2;
            this.current_location=null;
          };
          handleLocationChanged(location){
            let index=0;
            while(index<this.routes.length){
              const item=this.routes[index];
              const match=locationMatch(item.re,location);
              if(match!==null){
                let fn=(element)=>this.setElement(index,location,match,element);
                if(this.doRoute(item,fn,match)){
                  return;
                };
              };
              index+=1;
            };
            let fn=(element)=>this.setElement(-1,location,null,element);
            this.default_callback(fn);
            return;
          };
          doRoute(item,fn,match){
            item.callback(fn,match);
            return true;
          };
          setElement(index,location,match,element){
            if(!!element){
              if(index!=this.current_index){
                this.container.children=[element];
                this.container.update();
              };
              if(this.current_location!==location){
                this.setMatch(match);
                element.updateState({match:match});
              };
              this.current_index=index;
            }else{
              this.container.children=[];
              this.current_index=-1;
              this.container.update();
            };
            this.current_location=location;
          };
          addRoute(pattern,callback){
            const re=patternToRegexp(pattern);
            this.routes.push({pattern,callback,re});
          };
          setDefaultRoute(callback){
            this.default_callback=callback;
          };
          setMatch(match){

          };
        };
        class AuthenticatedRouter extends Router {
          constructor(container,route_list,default_callback){
            super(container,route_list,default_callback);
            this.authenticated=false;
          };
          doRoute(item,fn,match){
            let has_auth=this.isAuthenticated();
            if(item.auth===true&&item.noauth===undefined){
              if(!!has_auth){
                item.callback(fn,match);
                return true;
              }else if(item.fallback!==undefined){
                history.pushState({},"",item.fallback);
                return true;
              };
            };
            if(item.auth===undefined&&item.noauth===true){
              console.log(item,has_auth);
              if(!has_auth){
                item.callback(fn,match);
                return true;
              }else if(item.fallback!==undefined){
                history.pushState({},"",item.fallback);
                return true;
              };
            };
            if(item.auth===undefined&&item.noauth===undefined){
              item.callback(fn,match);
              return true;
            };
            return false;
          };
          isAuthenticated(){
            return this.authenticated;
          };
          setAuthenticated(value){
            this.authenticated=!!value;
          };
          addAuthRoute(pattern,callback,fallback){
            const re=patternToRegexp(pattern);
            this.routes.push({pattern,callback,auth:true,fallback,re});
          };
          addNoAuthRoute(pattern,callback,fallback){
            const re=patternToRegexp(pattern);
            this.routes.push({pattern,callback,noauth:true,fallback,re});
          };
        };
        return[AuthenticatedRouter,Router,locationMatch,patternCompile,patternToRegexp];
        
      })();
    const[downloadFile,uploadFile]=(function(){
        function saveBlob(blob,fileName){
          let a=document.createElement('a');
          a.href=window.URL.createObjectURL(blob);
          a.download=fileName;
          a.dispatchEvent(new MouseEvent('click'));
        };
        function downloadFile(url,headers={},params={},success=null,failure=null){
        
          const postData=new FormData();
          const queryString=util.serializeParameters(params);
          const xhr=new XMLHttpRequest();
          xhr.open('GET',url+queryString);
          for(let key in headers){
            xhr.setRequestHeader(key,headers[key]);
          };
          xhr.responseType='blob';
          xhr.onload=function(this_,event_){
            let blob=this_.target.response;
            if(!blob||this_.target.status!=200){
              if(failure!==null){
                failure({status:this_.target.status,blob});
              };
            }else{
              let contentDispo=xhr.getResponseHeader('Content-Disposition');
              console.log(xhr);
              let fileName;
              if(contentDispo!==null){
                fileName=contentDispo.match(/filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/)[
                                1];
              };
              if(!fileName){
                console.error("filename not found in xhr request header 'Content-Disposition'");
                
                let parts;
                parts=xhr.responseURL.split('/');
                parts=parts[parts.length-1].split('?');
                fileName=parts[0]||'resource.bin';
              };
              saveBlob(blob,fileName);
              if(success!==null){
                success({url,fileName,blob});
              };
            };
          };
          xhr.send(postData);
        };
        function _uploadFileImpl(elem,urlbase,headers={},params={},success=null,failure=null,
                  progress=null){
          let queryString=util.serializeParameters(params);
          let arrayLength=elem.files.length;
          for(let i=0;i<arrayLength;i++){
            let file=elem.files[i];
            let bytesTransfered=0;
            let url;
            if(urlbase.endsWith('/')){
              url=urlbase+file.name;
            }else{
              url=urlbase+'/'+file.name;
            };
            url+=queryString;
            let xhr=new XMLHttpRequest();
            xhr.open('POST',url,true);
            for(let key in headers){
              xhr.setRequestHeader(key,headers[key]);
            };
            xhr.upload.onprogress=function(event){
              if(event.lengthComputable){
                if(progress!==null){
                  bytesTransfered=event.loaded;
                  progress({bytesTransfered,fileSize:file.size,fileName:file.name,
                                          finished:false});
                };
              };
            };
            xhr.onreadystatechange=function(){
              if(xhr.readyState==4&&xhr.status==200){
                if(success!==null){
                  let params={fileName:file.name,url,lastModified:file.lastModified,
                                      size:file.size,type:file.type};
                  success(params);
                  if(progress!==null){
                    progress({bytesTransfered:file.size,fileSize:file.size,fileName:file.name,
                                              finished:true});
                  };
                };
              }else if(xhr.status>=400){
                if(failure!==null){
                  let params={fileName:file.name,url,status:xhr.status};
                  failure(params);
                  if(progress!==null){
                    progress({bytesTransfered,fileSize:file.size,fileName:file.name,
                                              finished:true});
                  };
                };
              }else{
                console.log("xhr status changed: "+xhr.status);
              };
            };
            if(progress!==null){
              progress({bytesTransfered,fileSize:file.size,fileName:file.name,finished:false,
                                  first:true});
            };
            let fd=new FormData();
            fd.append('upload',file);
            xhr.send(fd);
          };
        };
        function uploadFile(urlbase,headers={},params={},success=null,failure=null,
                  progress=null){
          let element=document.createElement('input');
          element.type='file';
          element.hidden=true;
          element.onchange=(event)=>{
            _uploadFileImpl(element,urlbase,headers,params,success,failure,progress);
            
          };
          element.dispatchEvent(new MouseEvent('click'));
        };
        return[downloadFile,uploadFile];
      })();
    const[OSName,platform]=(function(){
        let nVer=navigator.appVersion;
        let nAgt=navigator.userAgent;
        let browserName=navigator.appName;
        let fullVersion=''+parseFloat(navigator.appVersion);
        let majorVersion=parseInt(navigator.appVersion,10);
        let nameOffset,verOffset,ix;
        if((verOffset=nAgt.indexOf("Opera"))!=-1){
          browserName="Opera";
          fullVersion=nAgt.substring(verOffset+6);
          if((verOffset=nAgt.indexOf("Version"))!=-1){
            fullVersion=nAgt.substring(verOffset+8);
          };
        }else if((verOffset=nAgt.indexOf("MSIE"))!=-1){
          browserName="Microsoft Internet Explorer";
          fullVersion=nAgt.substring(verOffset+5);
        }else if((verOffset=nAgt.indexOf("Chrome"))!=-1){
          browserName="Chrome";
          fullVersion=nAgt.substring(verOffset+7);
        }else if((verOffset=nAgt.indexOf("Safari"))!=-1){
          browserName="Safari";
          fullVersion=nAgt.substring(verOffset+7);
          if((verOffset=nAgt.indexOf("Version"))!=-1){
            fullVersion=nAgt.substring(verOffset+8);
          };
        }else if((verOffset=nAgt.indexOf("Firefox"))!=-1){
          browserName="Firefox";
          fullVersion=nAgt.substring(verOffset+8);
        }else if((nameOffset=nAgt.lastIndexOf(' ')+1)<(verOffset=nAgt.lastIndexOf(
                          '/'))){
          browserName=nAgt.substring(nameOffset,verOffset);
          fullVersion=nAgt.substring(verOffset+1);
          if(browserName.toLowerCase()==browserName.toUpperCase()){
            browserName=navigator.appName;
          };
        };
        if((ix=fullVersion.indexOf(";"))!=-1){
          fullVersion=fullVersion.substring(0,ix);
        };
        if((ix=fullVersion.indexOf(" "))!=-1){
          fullVersion=fullVersion.substring(0,ix);
        };
        majorVersion=parseInt(''+fullVersion,10);
        if(isNaN(majorVersion)){
          fullVersion=''+parseFloat(navigator.appVersion);
          majorVersion=parseInt(navigator.appVersion,10);
        };
        let OSName="Unknown OS";
        if(navigator.appVersion.indexOf("Win")!=-1){
          OSName="Windows";
        };
        if(navigator.appVersion.indexOf("Mac")!=-1){
          OSName="MacOS";
        };
        if(navigator.appVersion.indexOf("X11")!=-1){
          OSName="UNIX";
        };
        if(navigator.appVersion.indexOf("Linux")!=-1){
          OSName="Linux";
        };
        function getDefaultFontSize(parentElement){
          parentElement=parentElement||document.body;
          let div=document.createElement('div');
          div.style.width="1000em";
          parentElement.appendChild(div);
          let pixels=div.offsetWidth/1000;
          parentElement.removeChild(div);
          return pixels;
        };
        const isMobile={Android:function(){
            return navigator.userAgent.match(/Android/i);
          },BlackBerry:function(){
            return navigator.userAgent.match(/BlackBerry/i);
          },iOS:function(){
            return navigator.userAgent.match(/iPhone|iPad|iPod/i);
          },Opera:function(){
            return navigator.userAgent.match(/Opera Mini/i);
          },Windows:function(){
            return navigator.userAgent.match(/IEMobile/i)||navigator.userAgent.match(
                          /WPDesktop/i);
          },any:function(){
            return(isMobile.Android()||isMobile.BlackBerry()||isMobile.iOS()||isMobile.Opera(
                            )||isMobile.Windows());
          }};
        const platform={OSName,browser:browserName,fullVersion,majorVersion,appName:navigator.appName,
                  userAgent:navigator.userAgent,platform:build_platform||'web',isAndroid:build_platform==='android',
                  isMobile:(!!isMobile.any())};
        console.log(platform);
        return[OSName,platform];
      })();
    const[render,render_update]=(function(){
        let workstack=[];
        let deletions=[];
        let deletions_removed=new Set();
        let updatequeue=[];
        let wipRoot=null;
        let currentRoot=null;
        let workLoopActive=false;
        let workCounter=0;
        function render(container,element){
          wipRoot={type:"ROOT",dom:container,props:{},children:[element],_fibers:[
                        ],alternate:currentRoot};
          workstack.push(wipRoot);
          if(!workLoopActive){
            workLoopActive=true;
            setTimeout(workLoop,0);
          };
        };
        function render_update(element){
          if(!element.dirty&&element._fiber!==null){
            element.dirty=true;
            const fiber={effect:'UPDATE',children:[element],_fibers:[],alternate:null,
                          partial:true};
            updatequeue.push(fiber);
          };
          if(!workLoopActive){
            workLoopActive=true;
            setTimeout(workLoop,0);
          };
        };
        DomElement.prototype._update=render_update;
        function workLoop(deadline=null){
          let shouldYield=false;
          const initialWorkLength=workstack.length;
          const initialUpdateLength=updatequeue.length;
          let friendly=deadline!=null;
          let initial_delay=0;
          try{
            if(!!friendly){
              initial_delay=deadline.timeRemaining();
              while(!shouldYield){
                while(workstack.length>0&&!shouldYield){
                  let unit=workstack.pop();
                  performUnitOfWork(unit);
                  shouldYield=deadline.timeRemaining()<1;
                };
                if(workstack.length==0&&wipRoot){
                  commitRoot();
                };
                if(workstack.length==0&&updatequeue.length>0&&!wipRoot){
                  wipRoot=updatequeue[0];
                  workstack.push(wipRoot);
                  updatequeue.shift();
                };
                shouldYield=deadline.timeRemaining()<1;
              };
            }else{
              while(1){
                while(workstack.length>0){
                  let unit=workstack.pop();
                  performUnitOfWork(unit);
                };
                if(wipRoot){
                  commitRoot();
                };
                if(updatequeue.length>0&&!wipRoot){
                  wipRoot=updatequeue[0];
                  workstack.push(wipRoot);
                  updatequeue.shift();
                }else{
                  break;
                };
              };
            };
          }catch(e){
            console.error("unhandled workloop exception: "+e.message);
          };
          let debug=workstack.length>1||updatequeue.length>1;
          if(!!debug){
            console.warn("workloop failed to finish",initial_delay,":",initialWorkLength,
                          '->',workstack.length,initialUpdateLength,'->',updatequeue.length);
            
            if(!friendly){
              setTimeout(workLoop,50);
            }else{
              requestIdleCallback(workLoop);
            };
          }else{
            workLoopActive=false;
          };
        };
        function performUnitOfWork(fiber){
          if(!fiber.dom&&fiber.effect=='CREATE'){
            fiber.dom=createDomNode(fiber);
          };
          reconcileChildren(fiber);
        };
        function reconcileChildren(parentFiber){
          workCounter+=1;
          const oldParentFiber=parentFiber.alternate;
          if(!!oldParentFiber){
            oldParentFiber.children.forEach(child=>{
                child._delete=true;
              });
          };
          let prev=parentFiber;
          while(prev.next){
            prev=prev.next;
          };
          parentFiber.children.forEach((element,index)=>{
              if(!element||!element.type){
                console.error(`${parentFiber.element.props.id}: undefined child element at index ${index} `);
                
                return;
              };
              const oldFiber=element._fiber;
              element._delete=false;
              const oldIndex=oldFiber?oldFiber.index:index;
              if(parentFiber.partial){
                index=oldIndex;
              };
              let effect;
              if(!!oldFiber){
                if(oldIndex==index&&element.dirty===false){
                  return;
                }else{
                  effect='UPDATE';
                };
              }else{
                effect='CREATE';
              };
              element.dirty=false;
              const newFiber={type:element.type,effect:effect,props:{...element.props},
                              children:element.children.slice(),_fibers:[],parent:(parentFiber.partial&&oldFiber)?oldFiber.parent:parentFiber,
                              alternate:oldFiber,dom:oldFiber?oldFiber.dom:null,signals:element.signals,
                              element:element,index:index,oldIndex:oldIndex};
              if(!newFiber.parent.dom){
                console.error(`element parent is not mounted id: ${element.props.id} effect: ${effect}`);
                
                return;
              };
              if(newFiber.props.style){
                console.warn("unsafe use of inline style: ",newFiber.type,element.props.id,
                                  newFiber.props.style);
              };
              if(typeof(newFiber.props.style)==='object'){
                newFiber.props.style=util.object2style(newFiber.props.style);
              };
              if(Array.isArray(newFiber.props.className)){
                newFiber.props.className=newFiber.props.className.join(' ');
              };
              element._fiber=newFiber;
              parentFiber._fibers.push(newFiber);
              prev.next=newFiber;
              prev=newFiber;
              workstack.push(newFiber);
            });
          if(!!oldParentFiber){
            oldParentFiber.children.forEach(child=>{
                if(child._delete){
                  deletions.push(child._fiber);
                };
              });
          };
        };
        function commitRoot(){
          deletions_removed=new Set();
          deletions.forEach(removeDomNode);
          if(deletions_removed.size>0){
            deletions_removed.forEach(elem=>{
                requestIdleCallback(elem.elementUnmounted.bind(elem));
              });
          };
          let unit=wipRoot.next;
          let next;
          while(unit){
            commitWork(unit);
            next=unit.next;
            unit.next=null;
            unit=next;
          };
          currentRoot=wipRoot;
          wipRoot=null;
          deletions=[];
        };
        function commitWork(fiber){
          const parentDom=fiber.parent.dom;
          if(!parentDom){
            console.warn(`element has no parent. effect: ${fiber.effect}`);
            return;
          };
          if(fiber.effect==='CREATE'){
            const length=parentDom.children.length;
            const position=fiber.index;
            if(length==position){
              parentDom.appendChild(fiber.dom);
            }else{
              parentDom.insertBefore(fiber.dom,parentDom.children[position]);
            };
            if(fiber.element.elementMounted){
              requestIdleCallback(fiber.element.elementMounted.bind(fiber.element));
              
            };
          }else if(fiber.effect==='UPDATE'){
            fiber.alternate.alternate=null;
            updateDomNode(fiber);
          }else if(fiber.effect==='DELETE'){
            fiber.alternate.alternate=null;
            removeDomNode(fiber);
          };
        };
        const isEvent=key=>key.startsWith("on");
        const isProp=key=>!isEvent(key);
        const isCreate=(prev,next)=>key=>(key in next&&!(key in prev));
        const isUpdate=(prev,next)=>key=>(key in prev&&key in next&&prev[key]!==next[
                    key]);
        const isDelete=(prev,next)=>key=>!(key in next);
        function createDomNode(fiber){
          const dom=fiber.type=="TEXT_ELEMENT"?document.createTextNode(""):document.createElement(
                      fiber.type);
          Object.keys(fiber.props).filter(isEvent).forEach(key=>{
              const event=key.toLowerCase().substring(2);
              dom.addEventListener(event,fiber.props[key]);
            });
          Object.keys(fiber.props).filter(isProp).forEach(key=>{
              dom[key]=fiber.props[key];
            });
          return dom;
        };
        function updateDomNode(fiber){
          const dom=fiber.dom;
          const parentDom=fiber.parent.dom;
          const oldProps=fiber.alternate.props;
          const newProps=fiber.props;
          if(!dom){
            console.log("fiber does not contain a dom");
            return;
          };
          if(fiber.oldIndex!=fiber.index&&parentDom){
            if(parentDom.children[fiber.index]!==dom){
              parentDom.removeChild(fiber.dom);
              parentDom.insertBefore(fiber.dom,parentDom.children[fiber.index]);
            };
          };
          Object.keys(oldProps).filter(isEvent).filter(key=>isUpdate(oldProps,newProps)(
                          key)||isDelete(oldProps,newProps)(key)).forEach(key=>{
              const event=key.toLowerCase().substring(2);
              dom.removeEventListener(event,oldProps[key]);
            });
          Object.keys(newProps).filter(isEvent).filter(key=>isCreate(oldProps,newProps)(
                          key)||isUpdate(oldProps,newProps)(key)).forEach(key=>{
              const event=key.toLowerCase().substring(2);
              dom.addEventListener(event,newProps[key]);
            });
          Object.keys(oldProps).filter(isProp).filter(isDelete(oldProps,newProps)).forEach(
                      key=>{
              dom[key]="";
            });
          Object.keys(newProps).filter(isProp).filter(key=>isCreate(oldProps,newProps)(
                          key)||isUpdate(oldProps,newProps)(key)).forEach(key=>{
              dom[key]=newProps[key];
            });
        };
        function _removeDomNode_elementFixUp(element){
          if(element.elementUnmounted){
            deletions_removed.add(element);
          };
          element.children.forEach(child=>{
              child._fiber=null;
              _removeDomNode_elementFixUp(child);
            });
        };
        function removeDomNode(fiber){
          if(fiber.dom){
            if(fiber.dom.parentNode){
              fiber.dom.parentNode.removeChild(fiber.dom);
            };
          }else{
            console.error("failed to delete",fiber.element.type);
          };
          fiber.dom=null;
          fiber.element._fiber=null;
          fiber.alternate=null;
          _removeDomNode_elementFixUp(fiber.element);
        };
        return[render,render_update];
      })();
    return{AuthenticatedRouter,ButtonElement,DomElement,DraggableList,HeaderElement,
          LinkElement,ListElement,ListItemElement,NumberInputElement,OSName,Router,Signal,
          StyleSheet,TextElement,TextInputElement,build_platform,downloadFile,env,getStyleSheet,
          locationMatch,parseParameters,patternCompile,patternToRegexp,platform,render,
          render_update,uploadFile,util};
  })();
minesweeper=(function(daedalus){
    "use strict";
    const StyleSheet=daedalus.StyleSheet;
    const DomElement=daedalus.DomElement;
    const TextElement=daedalus.TextElement;
    const ListItemElement=daedalus.ListItemElement;
    const ListElement=daedalus.ListElement;
    const HeaderElement=daedalus.HeaderElement;
    const ButtonElement=daedalus.ButtonElement;
    const NumberInputElement=daedalus.NumberInputElement;
    const LinkElement=daedalus.LinkElement;
    const style={header:'dcs-dbe5cb86-0',row:'dcs-dbe5cb86-1',board:'dcs-dbe5cb86-2',
          cell:'dcs-dbe5cb86-3',cell2:'dcs-dbe5cb86-4',cellf:'dcs-dbe5cb86-5',cellm:'dcs-dbe5cb86-6',
          padding:'dcs-dbe5cb86-7',center_block:'dcs-dbe5cb86-8',block:'dcs-dbe5cb86-9',
          button:'dcs-dbe5cb86-10',panel:'dcs-dbe5cb86-11',panelRow:'dcs-dbe5cb86-12',
          numberInput:'dcs-dbe5cb86-13'};
    ;
    ;
    class GameCell extends DomElement {
      constructor(board,row,col){
        super("div",{className:style.cell},[]);
        this.text=this.appendChild(new TextElement("0"));
        this.updateState({isRevealed:false,isFlagged:false,isMine:false,count:0,board,
                      row,col});
      };
      onClick(){
        this.state.board.handleLeftClick(this);
      };
      onContextMenu(event){
        event.preventDefault();
        this.state.board.handleRightClick(this);
        return false;
      };
      elementUpdateProps(oldProps,newProps){
        this.recomputeCellContent(this.state);
        return true;
      };
      elementUpdateState(oldState,newState){
        this.recomputeCellContent(newState);
        return true;
      };
      recomputeCellContent(state){
        if(state.isRevealed){
          if(state.isMine){
            this.text.setText("x");
          }else if(state.count>0){
            this.text.setText(state.count);
          }else{
            this.text.setText("");
          };
        }else{
          this.text.setText("");
        };
      };
    };
    class GamePanel extends DomElement {
      constructor(width,height,mineCount){
        super("div",{className:style.panel},[]);
        this.attrs={row1:new DomElement("div",{className:style.panelRow},[]),row2:new DomElement(
                      "div",{className:style.panelRow},[]),counter:new TextElement(""),btnNewGame:new ButtonElement(
                      "New Game",this.handleNewGame.bind(this)),newGame:()=>{
            console.log("error");
          },inpWidth:new NumberInputElement(),inpHeight:new NumberInputElement(),
                  inpCount:new NumberInputElement()};
        this.attrs.btnNewGame.addClassName(style.button);
        this.attrs.inpWidth.updateProps({maxlength:2,size:2,max:75,value:width});
        
        this.attrs.inpHeight.updateProps({maxlength:2,size:2,max:75,value:height});
        
        this.attrs.inpCount.updateProps({maxlength:2,size:2,max:75,value:mineCount});
        
        this.attrs.inpWidth.addClassName(style.numberInput);
        this.attrs.inpHeight.addClassName(style.numberInput);
        this.attrs.inpCount.addClassName(style.numberInput);
        this.appendChild(this.attrs.row1);
        this.appendChild(this.attrs.row2);
        this.attrs.row1.appendChild(this.attrs.counter);
        this.attrs.row1.appendChild(this.attrs.btnNewGame);
        this.attrs.row2.appendChild(new TextElement("W:"));
        this.attrs.row2.appendChild(this.attrs.inpWidth);
        this.attrs.row2.appendChild(new TextElement("H:"));
        this.attrs.row2.appendChild(this.attrs.inpHeight);
        this.attrs.row2.appendChild(new TextElement("Mines:"));
        this.attrs.row2.appendChild(this.attrs.inpCount);
      };
      setMineCount(count){
        this.attrs.counter.setText(`Mines: ${count}`);
      };
      handleNewGame(event){
        console.log(this.attrs.newGame);
        this.attrs.newGame(this.attrs.inpWidth.props.value,this.attrs.inpHeight.props.value,
                  this.attrs.inpCount.props.value);
      };
      setNewGameCallback(callback){
        this.attrs.newGame=callback;
      };
    };
    class GameBoard extends DomElement {
      constructor(width,height,mineCount){
        super("div",{className:style.board},[]);
        this.attrs={panel:new GamePanel(width,height,mineCount),initialized:false};
        
        this.reset(width,height,mineCount);
        this.attrs.panel.setNewGameCallback(this.reset.bind(this));
      };
      reset(width,height,mineCount){
        this.children=[];
        this.attrs.initialized=false;
        this.updateState({width:width,height:height,mineCount:mineCount,flagCount:0});
        
        let row=0;
        while(row<height){
          const row_elem=this.appendChild(new DomElement("div",{className:style.row},
                          []));
          let col=0;
          while(col<width){
            row_elem.appendChild(new GameCell(this,row,col));
            col++;
          };
          row++;
        };
        this.appendChild(this.attrs.panel);
        this.attrs.panel.setMineCount(mineCount);
      };
      placeMines(mrow,mcol){
        let placed=0;
        while(placed<this.state.mineCount){
          let row=daedalus.util.randomInt(0,this.state.height-1);
          let col=daedalus.util.randomInt(0,this.state.width-1);
          if(row==mrow&&col==mcol){
            continue;
          };
          const cell=this.children[row].children[col];
          if(!cell.state.isMine){
            cell.updateState({isMine:true});
            placed++;
          };
        };
      };
      computeCounts(){
        for(let row=0;row<this.state.height;row++){
          for(let col=0;col<this.state.width;col++){
            if(this.indexIsMine(row,col)){
              this.incrementCount(row-1,col-1);
              this.incrementCount(row-1,col);
              this.incrementCount(row-1,col+1);
              this.incrementCount(row,col-1);
              this.incrementCount(row,col+1);
              this.incrementCount(row+1,col-1);
              this.incrementCount(row+1,col);
              this.incrementCount(row+1,col+1);
            };
          };
        };
      };
      indexIsMine(row,col){
        if(row>=0&&row<this.state.height){
          if(col>=0&&col<this.state.width){
            return this.children[row].children[col].state.isMine;
          };
        };
        return false;
      };
      incrementCount(row,col){
        if(row>=0&&row<this.state.height){
          if(col>=0&&col<this.state.width){
            const cell=this.children[row].children[col];
            cell.updateState({count:cell.state.count+1},false);
          };
        };
      };
      handleLeftClick(cell){
        if(!this.attrs.initialized){
          this.placeMines(cell.state.row,cell.state.col);
          this.computeCounts();
          this.attrs.initialized=true;
        };
        this.revealCell(cell.state.row,cell.state.col);
      };
      handleRightClick(cell){
        if(!cell.state.isRevealed){
          this.flagCell(cell,!cell.state.isFlagged);
        };
      };
      flagCell(cell,flag){
        const prev=cell.state.isFlagged;
        if(prev==flag){
          return;
        };
        if(this.state.flagCount==this.state.mineCount&&flag){
          return;
        };
        cell.updateState({isFlagged:flag});
        if(cell.state.isFlagged){
          this.updateState({flagCount:this.state.flagCount+1});
          cell.updateProps({className:style.cellf});
        }else{
          this.updateState({flagCount:this.state.flagCount-1});
          cell.updateProps({className:style.cell});
        };
        this.attrs.panel.setMineCount(this.state.mineCount-this.state.flagCount);
        
      };
      revealCell(row,col){
        const queue=[[row,col]];
        const visited={};
        const enqueue=(r,c)=>{
          if(r>=0&&r<this.state.height){
            if(c>=0&&c<this.state.width){
              const idx=r*this.state.width+c;
              if(!visited[idx]){
                queue.push([r,c]);
              };
            };
          };
        };
        while(queue.length>0){
          [row,col]=queue.shift();
          const idx=row*this.state.width+col;
          if(visited[idx]===true){
            continue;
          };
          visited[idx]=true;
          const cell=this.children[row].children[col];
          if(cell.state.isFlagged){

          }else if(cell.state.isMine){
            for(let i=0;i<this.state.height;i++){
              for(let j=0;j<this.state.width;j++){
                const c=this.children[i].children[j];
                if(c.state.isMine){
                  c.updateState({isRevealed:true});
                  c.updateProps({className:style.cellm});
                };
              };
            };
          }else if(!cell.state.isRevealed){
            if(cell.state.count===0){
              enqueue(row-1,col-1);
              enqueue(row-1,col);
              enqueue(row-1,col+1);
              enqueue(row,col-1);
              enqueue(row,col+1);
              enqueue(row+1,col-1);
              enqueue(row+1,col);
              enqueue(row+1,col+1);
            };
            cell.updateState({isRevealed:true});
            cell.updateProps({className:style.cell2});
          }else if(cell.state.isRevealed&&Object.keys(visited).length==1){
            let cells=[];
            for(let i=row-1;i<=row+1;i++){
              for(let j=col-1;j<=col+1;j++){
                if(i>=0&&i<this.state.height){
                  if(j>=0&&j<this.state.width){
                    cells.push(this.children[i].children[j]);
                  };
                };
              };
            };
            cells=cells.filter(c=>!c.state.isRevealed);
            const flag=!cells.reduce((a,c)=>a&&c.state.isFlagged,true);
            cells.forEach(c=>{
                this.flagCell(c,flag);
              });
          };
        };
      };
    };
    class Game extends DomElement {
      constructor(){
        super("div",{className:style.block},[]);
        const em_width=getComputedStyle(document.querySelector('body'))['font-size'];
        
        const width=window.innerWidth/parseFloat(em_width);
        const default_size=Math.floor(Math.min(0.7*(width/1.7),15));
        const default_count=Math.ceil(0.15*default_size*default_size);
        this.appendChild(new DomElement("h2",{className:style.header},[new TextElement(
                              "Minesweeper")]));
        this.appendChild(new DomElement("div",{className:style.header},[new LinkElement(
                              "Powered By Daedalus","https://github.com/nsetzer/daedalus/")]));
        
        this.appendChild(new DomElement("div",{className:style.padding},[]));
        let div;
        div=this.appendChild(new DomElement("div",{className:style.center_block},
                      []));
        this.board=new GameBoard(default_size,default_size,default_count);
        div.appendChild(new DomElement("div",{className:style.center_block},[this.board]));
        
        this.appendChild(new DomElement("div",{className:style.padding},[]));
        div=this.appendChild(new DomElement("div",{className:style.center_block},
                      []));
        div.appendChild(new TextElement("Tap / Left Click - Reveal"));
        div.appendChild(new DomElement("br",{},[]));
        div.appendChild(new TextElement("Right Click - Flag"));
        div.appendChild(new DomElement("br",{},[]));
        div.appendChild(new TextElement("Tap a revealed cell to flag adjacent cells"));
        
      };
    };
    return{Game};
  })(daedalus);
</script>
</head>
<body>
<div id="root">Enable Javascript to render site.</div>
</body>
<script type="text/javascript">
const document_root = document.getElementById("root")
while (document_root.hasChildNodes()) {
    document_root.removeChild(document_root.lastChild);
}
daedalus.render(document_root, new minesweeper.Game())
</script>
</html>
